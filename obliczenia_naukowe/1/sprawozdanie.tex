% TODO: co to znaczy wartosc znormalizowana/ozdenormalizowana?
% TODO: lepsze wnioski moze

% TODO: odpowiedzi na pytania
% TODO: wnioski
% TODO: komentarze do programow
\documentclass[15pt, a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{adjustbox}
\title{Obliczenia naukowe}
\author{Felix Zieliński 272336}
\date{Lista 1}
\begin{document}
\maketitle
Rozwiązania zadań z 1. listy na przedmiot Obliczenia Naukowe. Programy zostały napisane w języku Julia oraz, gdy było to konieczne, w C.

\vspace{0.5cm}

\noindent\hrulefill

% zadanie 1

\vspace{0.5cm}

\noindent\textbf{Zadanie 1.} 

\textbf{a.} Wyznaczanie iteracyjne epsilonów maszynowych wraz z porównaniem z wartościami zwracanymi przez funkcję esp() oraz z danymi z headera float.h jezyka C.

\vspace{0.5cm}

Iteracyjnie dzielę wartość zmiennej \verb|macheps| przez dwa, zaczynając od wartości 1 w danym typie zmiennoprzecinkowym, aż warunek pętli while \verb|1 + macheps > 1| nie zostanie spełniony. 

% TODO: bardziej wyrównac te tabele
% TODO: eeeee te wartosci w c 
% TODO: wnioski
% TODO: opis algorytmu
% TODO: moze np co to macheps, eta itp??
% TODO: odpowiedzi na pytania z zadania

\begin{table}[ht]
    \begin{adjustbox}{max width=\textwidth}
    \begin{tabular}{|c|c|c|c|}
        \hline 
        Typ zmiennoprzecinkowy & Wyznaczona wartośc macheps & eps() & <float.h> \\ \hline
        16 & 0.000977 & 0.000977 & brak \\ \hline
        32 & 1.1920929e-7 & 1.1920929e-7 & 1.1920929e-07  \\ \hline
        64 & 2.220446049250313e-16 & 2.220446049250313e-16 &  2.2204460492503131e-16 \\ \hline
    \end{tabular}
    \end{adjustbox}
    \label{tab:macheps}
\end{table}

Moje wyniki zgadzają się z prawdziwymi wartościami \\
Wyznaczony epsilon maszynowy pomaga w ustaleniu precyzji zapisu liczb zmiennoprzecinkowych, gdyż jest odległością od 1 do kolejnej liczby możliwej do zaprezentowania w danym typie. Im mniejsza będzie ta wartość, tym większa będzie precyzja względna obliczeń.

\vspace{0.5cm}

\textbf{b. } Wyznaczenie iteracyjnie liczby maszynowej eta wraz z porównaniem z wartościami zwracanymi przez funkcję nextfloat()

\vspace{0.5cm}

Iteracyjnie dzielę wartości zmiennej \verb|eta| przez dwa począwszy od wartości zmiennej równej 1,aż warunek pętli while \verb|eta > 0| nie zostanie spełniony. 

\begin{table}[ht]
    \begin{tabular}{|c|c|c|}
        \hline 
        Typ zmiennoprzecinkowy & Wyznaczona wartośc eta & nextfloat() \\ \hline
        16 & 6.0e-8 & 6.0e-8 \\ \hline
        32 & 1.0e-45 & 1.0e-45 \\ \hline
        64 & 5.0e-324 & 5.0e-324 \\ \hline
    \end{tabular}
    \label{tab:eta}
\end{table}

Wartości zwrócone przez
\begin{enumerate}
    \item \verb|floatmin(Float32)| - 1.1754944e-38
    \item \verb|floatmin(Float64)| - 2.2250738585072014e-308
\end{enumerate}

Tutaj również moje wyniki zgadzają się z prawdzimymi wartościami. \\
Liczba eta odpowiada najmniejszej zdenormalizowanej liczbie dodatniej reprezentowanej w podanej arytmetyce zmiennopozycyjnej. Jest zdenormalizowana, czyli bity cechy mają wartość 0. \\
Natomiast wartości zwrócone przez \verb|floatmin| są odpowiednikiem tej wartości, ale znormalizowanej.

\vspace{0.5cm}

\textbf{c. } Wyznaczenie iteracyjne liczby MAX wraz z porównaniem z wartościami zwracanymi przez funckje floatmax() oraz z danymi z headera float.h języka C.

\vspace{0.5cm}

Iteracyjnie mnożę wartości zmiennej \verb|max|, aż stanie się ona równa wartości \verb|isinf|. Następnie, w celu poprawienia dokładności obliczeń, dodaję do poprzedniej wartości \verb|max| $\frac{x}{k}$, gdzie \verb|k = 2, 4, ...|, aż \verb|max| będzie równa \verb|isinf| bądź mniejsza od 1

\begin{table}[ht]
    \begin{adjustbox}{max width=\textwidth}
    \begin{tabular}{|c|c|c|c|}
        \hline 
        Typ zmiennoprzecinkowy & Wyznaczona wartośc max & floatmax() & <float.h> \\ \hline
        16 & 6.55e4 & 6.55e4 & brak \\ \hline
        32 & 3.4028235e38 & 3.4028235e38 & 3.40282347e+38 \\ \hline
        64 & 1.7976931348623157e308 & 1.7976931348623157e308 & 1.7976931348623157e+308 \\ \hline
    \end{tabular}
    \end{adjustbox}
    \label{tab:max}
\end{table}

Moje wyniki zgadzają się z wartościami zwróconymi przez \verb|floatmax()|. \\
Obie wartości mają postać zdenormalizowaną

\noindent\hrulefill

% zadanie 2

\vspace{0.5cm}

\noindent\textbf{Zadanie 2.} Sprawdzenie, czy twierdzenie Kahana jest poprawne.

\vspace{0.5cm}

Twierdzenie to mówi, że epsilon maszynowy można uzyskać, obliczając wartość \[3 * (4 / 3 - 1) - 1\] w odpowiedniej arytmetyce zmiennoprzecinkowej. Sprawdzenia dokonuję obliczając tę wartośc dla wartości rzutowanych na podany typ. Jedynkę otrzymuję funkcją \verb|one|.

\begin{table}[ht]
    \begin{adjustbox}{max width=\textwidth}
    \begin{tabular}{|c|c|c|}
        \hline 
        Typ zmiennoprzecinkowy & Wyznaczona wartość & eps() \\ \hline
        16 & -0.000977 & 0.000977 \\ \hline
        32 & 1.1920929e-7 & 1.1920929e-7 \\ \hline
        64 & -2.220446049250313e-1 & 2.220446049250313e-16 \\ \hline
    \end{tabular}
    \end{adjustbox}
    \label{tab:kahan}
\end{table}

% TODO: sprawdzenie, czy nie pisze glupot ponizej

Obliczone wyniki praktycznie pokrywają się z prawdziwymi wartościami - nie licząc znaku. Zmiana znaku dla typów \verb|Float16| oraz \verb|Float64| może wynikać z ilości bitów znaczących w tych typach (odpowiednio, 10 oraz 52). Ponadto, rozwijając 4/3 binarnie, otrzymamy 1.(10). To powoduje, że ostatnią cyfrą mantysy w tych typach będzie 0, co zmienia znak na przeciwny. Tak więc, gdy weźmiemy moduł z obliczonych wartości, otrzymamy poprawne wyniki, więc twierdzenie Kahana w rzeczywistości jest poprawne.

\vspace{0.5cm}

\noindent\hrulefill

% zadanie 3

\vspace{0.5cm}

\noindent\textbf{Zadanie 3.} Sprawdzenie, czy liczby w arytmetyce \verb|Float(64)| liczby zmiennopozycyjne sa równomiernie rozmieszczone.

\vspace{0.5cm}

% TODO: tu tez sprawdzic, czy to nie glupota

Najprostrzym, a zarazem najdłuższym obliczeniowo rozwiązaniem jest iteracja przez wszystkie liczby z danego przedziału w celu porównania z wartościami \verb|nextfloat|. Szybciej jednak jest porównać eksponenty pierwszej oraz ostatniej liczby z przedziału. Jeśli byłyby inne, wykluczyłoby to rownomierny rozkład liczb w tym przedziale.

Funkcja potwierdza, że eksponenty są takie same. Ponadto wypisałem kilka początkowych liczb, co dalej potwierdza równomierne rozmieszczenie:
\[0011111111110000000000000000000000000000000000000000000000000000\]
\[0011111111110000000000000000000000000000000000000000000000000001\]
\[0011111111110000000000000000000000000000000000000000000000000010\]
\[0011111111110000000000000000000000000000000000000000000000000011\]
\[0011111111110000000000000000000000000000000000000000000000000100\]

\vspace{0.5cm}

Wiem, że odchylenie wykładnicze dla Float64 wynosi 1023. Mantysa ma 52 bity znaczące. Z tych informacji mogę wyliczyć, jak rozmieszczone są liczby w danym przedziale. Używam do tego wzoru $2^{\mathrm{exp - 1023}}$ * $2^{\mathrm{-52}}$. Wyliczone z tego wzoru kroki prezentują się następująco:
\[[0.5, 1] - 1.1102230246251565e-16\]
\[[1, 2] - 2.220446049250313e-16\]
\[[2, 4] - 4.440892098500626e-16\]

\vspace{0.5cm}

Odległości pomiędzy kolejnymi liczbami rosną wraz ze zwiększaniem się eksponenty, co jest zgodne ze standardem IEEE754, w którym liczby są reprezentowane z dokładnością różną w zależności od przedziału.

\vspace{0.5cm}

\noindent\hrulefill

% zadanie 4 

\vspace{0.5cm}

\noindent\textbf{Zadanie 4.} Znalezienie w arytmetyce \verb|Float(64)| liczbę zmiennopozycyjną \verb|x| w przedziale \verb|1 < x < 2| taką, że $x * (1/x) \neq 1$, a także najmniejszej takiej liczby.\\
Iteracyjnie sprawdzam kolejne wyniki działania $x * (1/x) \neq 1$, iterując po \verb|x| przy użyciu funkcji \verb|nextfloat|. Gdy tylko wynik będzie różny od 1, zwracam go, tym samym otrzymując najmnijeszą wartość w zadanym przedziale.\\
Najmniejsza znalezione przeze mnie liczba w przedziale (1, 2): \[\verb|1.000000057228997|\]
Niepoprawny wynik działania jest spowodowany niedokładnością, jaką są obarczone działania na liczbach zmiennoprzecinkowych. Trzeba zachować więc ostrożność podczas wykonywania obliczeń i brać pod uwagę, że mogą być one nieidealne.

\vspace{0.5cm}

\noindent\hrulefill

% zadanie 5  

\vspace{0.5cm}

\noindent\textbf{Zadanie 5.} Obliczanie iloczynu skalarnego dwóch wektorów na cztery rózne sposoby.\\
Zaimplementowałem każdy z podanych w poleceniu sposobów, tak więc funkcja \verb|a| liczy "w przód", od pierwszych indeksów, funkcja \verb|b| "w tył", analogiczne, a \verb|c| oraz \verb|d| liczą, odpowiednio, od największego do najmniejszego oraz od najmniejszego do największego.

\begin{table}[ht]
    \begin{adjustbox}{max width=\textwidth}
    \begin{tabular}{|c|c|c|c|}
        \hline 
        Sposób & Float32 & Float64 & Wartość prawidłowa \\ \hline
        1 & -0.3472038161853561  & 1.0251881368296672e-10 & -1.00657107000000e-11 \\ \hline
        2 & -0.3472038162872195 & -1.5643308870494366e-1 & -1.00657107000000e-11 \\ \hline
        3 & -0.3472038162872195 & 0.0 & -1.00657107000000e-11  \\ \hline
        4 & -0.3472038162872195 & 0.0 & -1.00657107000000e-11 \\ \hline
    \end{tabular}
    \end{adjustbox}
    \label{tab:products}
\end{table}

\vspace{0.5cm}

Jak widać w tabeli, żaden ze sposobów liczenia nie dał dokładnego wyniku, niezależnie od zastosowanej arytmetyki (\verb|Float32| bądź \verb|Float64|, chociaż ten drugi pozwolił na uzyskanie wyniku bliższego prawdziwej wartości). Widać również, że kolejność wykonywania działań wpływa na wynik.

\vspace{0.5cm}

\noindent\hrulefill

% zadanie 6 

\vspace{0.5cm}

% TODO: wiarygosnosc wyniku
\noindent\textbf{Zadanie 6.} Obliczanie wartości funkcji w arytmetyce \verb|Float64| dla kolejnych wartości argumentu x. Zadane funkcje:
\[
f(x) = \sqrt{x^2 + 1} - 1
\]

\[
g(x) = \frac{x^2}{\sqrt{x^2 + 1} + 1}
\]

Powyższe funkcje zaimplementowałem w niezmienionej formie.


\begin{table}[ht]
    \begin{tabular}{|c|c|c|}
        \hline 
        Wartość x & f(x) & g(x) \\ \hline
        $8^{\mathrm{-1}}$ & 0.0077822185373186414 & 0.0077822185373187065 \\ \hline
        $8^{\mathrm{-2}}$ & 0.00012206286282867573 & 0.00012206286282875901 \\ \hline
        $8^{\mathrm{-3}}$ & 1.9073468138230965e-6 & 1.907346813826566e-6 \\ \hline
        $8^{\mathrm{-4}}$ & 2.9802321943606103e-8 & 2.9802321943606116e-8 \\ \hline
        $8^{\mathrm{-5}}$ & 4.656612873077393e-10 & 4.6566128719931904e-10 \\ \hline
        $8^{\mathrm{-6}}$ & 7.275957614183426e-12 & 7.275957614156956e-12 \\ \hline
        $8^{\mathrm{-7}}$ & 1.1368683772161603e-13 & 1.1368683772160957e-13 \\ \hline
        $8^{\mathrm{-8}}$ & 1.7763568394002505e-15 & 1.7763568394002489e-15 \\ \hline
        $8^{\mathrm{-9}}$ & 0.0 & 2.7755575615628914e-17 \\ \hline
        $8^{\mathrm{-10}}$ & 0.0 & 4.336808689942018e-19 \\ \hline
    \end{tabular}
    \label{tab:fvsg}
\end{table}



\vspace{0.5cm}

\noindent\hrulefill

% zadanie 7 

\vspace{0.5cm}

\noindent\textbf{Zadanie 7.} 

\end{document}
